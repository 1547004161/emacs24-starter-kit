#+TITLE: Emacs Starter Kit
#+SEQ_TODO: PROPOSED TODO STARTED | DONE DEFERRED REJECTED
#+OPTIONS: H:2 num:nil toc:t
#+STARTUP: oddeven

#+begin_quote 
Emacs outshines all other editing software in approximately the
same way that the noonday sun does the stars. It is not just bigger
and brighter; it simply makes everything else vanish.
#+end_quote
-Neal Stephenson, "In the Beginning was the Command Line"

* Introduction

This should provide a saner set of defaults than you get normally with
Emacs. It's intended for beginners, but it should provide a reasonable
working environment for anyone using Emacs for dynamic languages. The
main advantage of the Starter Kit is that it provides better default
settings and bundles many useful libraries.

The latest version is at http://github.com/technomancy/emacs-starter-kit/

** Learning

This won't teach you Emacs, but it'll make it easier to get
comfortable. To access the tutorial, press control-h followed by t.

The [[http://emacswiki.org][Emacs Wiki]] is also very handy.

** Installation

1. Install Emacs (at least version 22) Use your package manager if you
   have one.  Otherwise, Mac users should get it [[http://www.apple.com/downloads/macosx/unix_open_source/carbonemacspackage.html][from Apple]], or
   install it directly from [[http://savannah.gnu.org/projects/emacs/][from source]] following the instructions in
   =nextstep/INSTALL=.  Windows users can get it [[http://ftp.gnu.org/gnu/emacs/windows/emacs-22.3-bin-i386.zip][from GNU]].
2. Move the directory containing this file to =~/.emacs.d= [1]
3. Launch Emacs!

If you are missing some autoloads after an update (should manifest
itself as "void function: foobar" errors) try M-x regen-autoloads.

If you want to keep your regular ~/.emacs.d in place and just launch a
single instance using the starter kit, try the following invocation:

#+begin_src sh
  emacs -q -l ~/src/emacs-starter-kit/init.el
#+end_src

Note that having a ~/.emacs file might override the starter kit
loading, so if you've having trouble loading it, make sure that file
is not present.

** Structure

The init.el file is where everything begins. It's the first file to
get loaded. Additional customization embedded in this file provides
what I consider to be better defaults, both for different programming
languages and for built-in Emacs features like bindings or registers.

Files that are pending submission to [[* Emacs Lisp Package Archive][ELPA]] are bundled with the starter
kit under the directory [[file:elpa-to-submit/][elpa-to-submit/]]. The understanding is that
these are bundled just because nobody's gotten around to turning them
into packages, and the bundling of them is temporary. For these
libraries, autoloads will be generated and kept in the [[file:loaddefs.el][loaddefs.el]]
file. This allows them to be loaded on demand rather than at startup.
Additionally any emacs-lisp packages located under the [[file:src/][src/]] directory
will be added to the load-path.

There are also a few files that are meant for code that doesn't belong
in the Starter Kit. First, the user-specific-config file is the file
named after your user with the extensions =.el= or =.org= [2]. In
addition, if a directory named after your user exists, it will be
added to the load-path, and any elisp or org-mode w/embedded elisp
files in it will be loaded. Finally, the Starter Kit will look for a
file named after the current hostname ending in =.el= or =.org= which
will allow host-specific configuration. This is where you should put
code that you don't think would be useful to everyone. That will allow
you to merge with newer versions of the starter-kit without conflicts.

** Emacs Lisp Package Archive

Libraries from [[http://tromey.com/elpa][ELPA]] are preferred when available since dependencies
are handled automatically, and the burden to update them is removed
from the user. In the long term, ideally everything would be installed
via ELPA, and only [[file:package.el][package.el]] would need to be distributed with the
starter kit. (Or better yet, [[file:package.el][package.el]] would come with Emacs...) See
[[* Starter Kit
 ELPA][Starter Kit ELPA]] for a list of libraries that are pending submission
to ELPA. Packages get installed in the [[file:elpa/][elpa/]] directory.

There's no vendor/ directory in the starter kit because if an external
library is useful enough to be bundled with the starter kit, it should
be useful enough to submit to ELPA so that everyone can use it, not
just users of the starter kit.  However any packages included in the
[[file:src][src/]] directory will be added to the load-path, for tracking bleeding
edge packages.

Sometimes packages are removed from the Starter Kit as they get added
to ELPA itself. This has occasionally caused problems with certain
packages. If you run into problems with such a package, try removing
everything from inside the elpa/ directory and invoking M-x
starter-kit-elpa-install in a fresh instance.

** Contributing

If you know your way around Emacs, please try out the starter kit as a
replacement for your regular dotfiles for a while. If there's anything
you just can't live without, add it or let me know so I can add
it. Take a look at what happens in [[file:init.el][init.el]] to get started.

Also: see the [[* Tasks][Tasks section]] in this document. Helping submit new
libraries to ELPA is the easiest way to help out. There are two ways
you can do this: either take new libraries and make them ready for
ELPA, dropping them in the elpa-to-submit directory or take files that
are already in elpa-to-submit, ensuring all their dependencies are
correctly loaded into ELPA, and sending them to the ELPA
maintainer. There are details at http://tromey.com/elpa/upload.html
for how ELPA submission works. Grep the project for TODO for other
things.

Files are licensed under the same license as Emacs unless otherwise
specified. See the file COPYING for details.

The latest version is at http://github.com/technomancy/emacs-starter-kit/

On Unix, =/home/$USER/.emacs.d=, on windows =Documents and
Settings/%your user name%/Application Data=


* Implementation
This section contains all code implementing the Emacs Starter Kit.

** Starter Kit Basics

*** Load path etc.

#+srcname: starter-kit-load-paths
#+begin_src emacs-lisp 
  (setq dotfiles-dir (file-name-directory
                      (or (buffer-file-name) load-file-name)))
  
  (add-to-list 'load-path dotfiles-dir)
  (add-to-list 'load-path (concat dotfiles-dir "/elpa-to-submit"))
  (add-to-list 'load-path (concat dotfiles-dir "/elpa-to-submit/jabber"))
  
  (setq autoload-file (concat dotfiles-dir "loaddefs.el"))
  (setq package-user-dir (concat dotfiles-dir "elpa"))
  (setq custom-file (concat dotfiles-dir "custom.el"))
#+end_src

*** Ubiquitous Packages

These should be loaded on startup rather than autoloaded on demand
since they are likely to be used in every session

#+srcname: starter-kit-load-on-startup
#+begin_src emacs-lisp 
  (require 'cl)
  (require 'saveplace)
  (require 'ffap)
  (require 'uniquify)
  (require 'ansi-color)
  (require 'recentf)
#+end_src

*** Emacs 22 Backport

backport some functionality to Emacs 22 if needed
#+srcname: starter-kit-emacs-22-helper
#+begin_src emacs-lisp 
  (require 'dominating-file)
#+end_src

this must be loaded before ELPA since it bundles its own
out-of-date js stuff. TODO: fix it to use ELPA dependencies
#+srcname: start-kit-nxhtml
#+begin_src emacs-lisp 
  (load "elpa-to-submit/nxhtml/autostart")
#+end_src

*** ELPA (Emacs Lisp Package Manager)

Load up [[http://tromey.com/elpa/][ELPA]], the Emacs Lisp package manager

#+srcname: start-kit-elpa
#+begin_src emacs-lisp 
  (require 'package)
  (package-initialize)
  (org-babel-load-file "starter-kit-elpa.org")
#+end_src

*** Starter Kit Customizations

Load up starter kit customizations

#+srcname: start-kit-customizations
#+begin_src emacs-lisp 
  (load custom-file 'noerror)
#+end_src

*** Work around OS X bug

Work around a bug on OS X where system-name is FQDN
#+srcname: start-kit-osX-workaround
#+begin_src emacs-lisp 
  (if (eq system-type 'darwin)
      (setq system-name (car (split-string system-name "\\."))))
#+end_src

*** System/User specific customizations

You can keep system- or user-specific customizations here in either
raw emacs-lisp files or as embedded elisp in org-mode files (as done
in this document).

#+srcname: start-kit-user/system-setup
#+begin_src emacs-lisp 
  (setq system-specific-config (concat dotfiles-dir system-name ".el")
        system-specific-literate-config (concat dotfiles-dir system-name ".org")
        user-specific-config (concat dotfiles-dir user-login-name ".el")
        user-specific-literate-config (concat dotfiles-dir user-login-name ".org")
        user-specific-dir (concat dotfiles-dir user-login-name))
  (add-to-list 'load-path user-specific-dir)
  
  (if (file-exists-p system-specific-config) (load system-specific-config))
  (if (file-exists-p system-specific-literate-config)
      (org-babel-load system-specific-literate-config))
  (if (file-exists-p user-specific-config) (load user-specific-config))
  (if (file-exists-p user-specific-literate-config)
      (org-babel-load user-specific-literate-config))
  (when (file-exists-p user-specific-dir)
    (mapc #'load (directory-files user-specific-dir nil ".*el$"))
    (mapc #'org-babel-load (directory-files user-specific-dir nil ".*org$")))
#+end_src

** Starter Kit Defuns

#+begin_src emacs-lisp
(require 'thingatpt)
(require 'imenu)
#+end_src

*** Network

#+srcname: start-kit-view-url
#+begin_src emacs-lisp 
  (defun view-url ()
    "Open a new buffer containing the contents of URL."
    (interactive)
    (let* ((default (thing-at-point-url-at-point))
           (url (read-from-minibuffer "URL: " default)))
      (switch-to-buffer (url-retrieve-synchronously url))
      (rename-buffer url t)
      ;; TODO: switch to nxml/nxhtml mode
      (cond ((search-forward "<?xml" nil t) (xml-mode))
            ((search-forward "<html" nil t) (html-mode)))))
#+end_src

*** Buffer-related

#+srcname: starter-kit-ido-imenu
#+begin_src emacs-lisp 
  (defun ido-imenu ()
    "Update the imenu index and then use ido to select a symbol to navigate to.
  Symbols matching the text at point are put first in the completion list."
    (interactive)
    (imenu--make-index-alist)
    (let ((name-and-pos '())
          (symbol-names '()))
      (flet ((addsymbols (symbol-list)
                         (when (listp symbol-list)
                           (dolist (symbol symbol-list)
                             (let ((name nil) (position nil))
                               (cond
                                ((and (listp symbol) (imenu--subalist-p symbol))
                                 (addsymbols symbol))
                                
                                ((listp symbol)
                                 (setq name (car symbol))
                                 (setq position (cdr symbol)))
                                
                                ((stringp symbol)
                                 (setq name symbol)
                                 (setq position (get-text-property 1 'org-imenu-marker symbol))))
                               
                               (unless (or (null position) (null name))
                                 (add-to-list 'symbol-names name)
                                 (add-to-list 'name-and-pos (cons name position))))))))
        (addsymbols imenu--index-alist))
      ;; If there are matching symbols at point, put them at the beginning of `symbol-names'.
      (let ((symbol-at-point (thing-at-point 'symbol)))
        (when symbol-at-point
          (let* ((regexp (concat (regexp-quote symbol-at-point) "$"))
                 (matching-symbols (delq nil (mapcar (lambda (symbol)
                                                       (if (string-match regexp symbol) symbol))
                                                     symbol-names))))
            (when matching-symbols
              (sort matching-symbols (lambda (a b) (> (length a) (length b))))
              (mapc (lambda (symbol) (setq symbol-names (cons symbol (delete symbol symbol-names))))
                    matching-symbols)))))
      (let* ((selected-symbol (ido-completing-read "Symbol? " symbol-names))
             (position (cdr (assoc selected-symbol name-and-pos))))
        (goto-char position))))
#+end_src

*** These belong in coding-hook:

We have a number of turn-on-* functions since it's advised that lambda
functions not go in hooks. Repeatedly evaling an add-to-list with a
hook value will repeatedly add it since there's no way to ensure that
a lambda doesn't already exist in the list.

#+srcname: starter-kit-hook-functions
#+begin_src emacs-lisp 
(defun local-column-number-mode ()
  (make-local-variable 'column-number-mode)
  (column-number-mode t))

(defun local-comment-auto-fill ()
  (set (make-local-variable 'comment-auto-fill-only-comments) t)
  (auto-fill-mode t))

(defun turn-on-hl-line-mode ()
  (if window-system (hl-line-mode t)))

(defun turn-on-save-place-mode ()
  (setq save-place t))

(defun turn-on-whitespace ()
  (whitespace-mode t))
#+end_src

#+srcname: starter-kit-add-local-column-number-mode
#+begin_src emacs-lisp 
(add-hook 'coding-hook 'local-column-number-mode)
#+end_src

#+srcname: start-kit-add-local-comment-auto-fill
#+begin_src emacs-lisp 
(add-hook 'coding-hook 'local-comment-auto-fill)
#+end_src

#+srcname: starter-kit-add-hl-line-mode
#+begin_src emacs-lisp 
(add-hook 'coding-hook 'turn-on-hl-line-mode)
#+end_src

#+srcname: starter-kit-add-pretty-lambdas
#+begin_src emacs-lisp 
(add-hook 'coding-hook 'pretty-lambdas)
#+end_src
  
#+srcname: starter-kit-run-coding-hook
#+begin_src emacs-lisp 
(defun run-coding-hook ()
  "Enable things that are convenient across all coding buffers."
  (run-hooks 'coding-hook))
#+end_src

#+srcname: starter-kit-untabify-buffer
#+begin_src emacs-lisp 
(defun untabify-buffer ()
  (interactive)
  (untabify (point-min) (point-max)))
#+end_src

#+srcname: starter-kit-indent-buffer
#+begin_src emacs-lisp 
(defun indent-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))
#+end_src

#+srcname: starter-kit-cleanup-buffer
#+begin_src emacs-lisp 
(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer."
  (interactive)
  (indent-buffer)
  (untabify-buffer)
  (delete-trailing-whitespace))
#+end_src

#+srcname: starter-kit-recentf-ido-find-file
#+begin_src emacs-lisp 
(defun recentf-ido-find-file ()
  "Find a recent file using ido."
  (interactive)
  (let ((file (ido-completing-read "Choose recent file: " recentf-list nil t)))
    (when file
      (find-file file))))
#+end_src

*** Cosmetic

#+srcname: starter-kit-pretty-lambdas
#+begin_src emacs-lisp 
(defun pretty-lambdas ()
  (font-lock-add-keywords
   nil `(("(?\\(lambda\\>\\)"
          (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                    ,(make-char 'greek-iso8859-7 107))
                    nil))))))
#+end_src

*** Other

#+srcname: starter-kit-other-functions
#+begin_src emacs-lisp 
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))
  
  (defun recompile-init ()
    "Byte-compile all your dotfiles again."
    (interactive)
    (byte-recompile-directory dotfiles-dir 0)
    ;; TODO: remove elpa-to-submit once everything's submitted.
    (byte-recompile-directory (concat dotfiles-dir "elpa-to-submit/" 0)))
  
  (defun regen-autoloads (&optional force-regen)
    "Regenerate the autoload definitions file if necessary and load it."
    (interactive "P")
    (let ((autoload-dir (concat dotfiles-dir "/elpa-to-submit"))
          (generated-autoload-file autoload-file))
      (when (or force-regen
                (not (file-exists-p autoload-file))
                (some (lambda (f) (file-newer-than-file-p f autoload-file))
                      (directory-files autoload-dir t "\\.el$")))
        (message "Updating autoloads...")
        (let (emacs-lisp-mode-hook)
          (update-directory-autoloads autoload-dir))))
    (load autoload-file))
#+end_src

TODO: fix this
#+srcname: starter-kit-sudo-edit
#+begin_src emacs-lisp 
(defun sudo-edit (&optional arg)
  (interactive "p")
  (if arg
      (find-file (concat "/sudo:root@localhost:" (ido-read-file-name "File: ")))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
#+end_src

Useful when a large block of text is required (e.g. for testing)
#+srcname: starter-kit-lorem
#+begin_src emacs-lisp 
(defun lorem ()
  "Insert a lorem ipsum."
  (interactive)
  (insert "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do "
          "eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim"
          "ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut "
          "aliquip ex ea commodo consequat. Duis aute irure dolor in "
          "reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla "
          "pariatur. Excepteur sint occaecat cupidatat non proident, sunt in "
          "culpa qui officia deserunt mollit anim id est laborum."))
#+end_src

#+srcname: starter-kit-switch-or-start
#+begin_src emacs-lisp 
(defun switch-or-start (function buffer)
  "If the buffer is current, bury it, otherwise invoke the function."
  (if (equal (buffer-name (current-buffer)) buffer)
      (bury-buffer)
    (if (get-buffer buffer)
        (switch-to-buffer buffer)
      (funcall function))))
#+end_src

#+srcname: starter-kit-insert-date
#+begin_src emacs-lisp 
(defun insert-date ()
  "Insert a time-stamp according to locale's date and time format."
  (interactive)
  (insert (format-time-string "%c" (current-time))))
#+end_src

#+srcname: starter-kit-pairing-bot
#+begin_src emacs-lisp 
(defun pairing-bot ()
  "If you can't pair program with a human, use this instead."
  (interactive)
  (message (if (y-or-n-p "Do you have a test for that? ") "Good." "Bad!")))
#+end_src

A monkeypatch to cause annotate to ignore whitespace

#+srcname: starter-kit-vc-git-annotate-command
#+begin_src emacs-lisp 
(defun vc-git-annotate-command (file buf &optional rev)
  (let ((name (file-relative-name file)))
    (vc-git-command buf 0 name "blame" "-w" rev)))
#+end_src

** Starter Kit Bindings

*** You know, like Readline.
#+begin_src emacs-lisp 
(global-set-key (kbd "C-M-h") 'backward-kill-word)
#+end_src

*** Align your code in a pretty way.
#+begin_src emacs-lisp 
(global-set-key (kbd "C-x \\") 'align-regexp)
#+end_src

*** Completion that uses many different methods to find options.
#+begin_src emacs-lisp 
(global-set-key (kbd "M-/") 'hippie-expand)
#+end_src

*** Perform general cleanup.
#+begin_src emacs-lisp 
(global-set-key (kbd "C-c n") 'cleanup-buffer)
#+end_src

*** Turn on the menu bar for exploring new modes
#+begin_src emacs-lisp 
(global-set-key [f1] 'menu-bar-mode)
#+end_src

*** Font size
#+begin_src emacs-lisp 
(define-key global-map (kbd "C-+") 'text-scale-increase)
(define-key global-map (kbd "C--") 'text-scale-decrease)
#+end_src

*** Use regex searches by default.
#+begin_src emacs-lisp 
(global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "\C-r") 'isearch-backward-regexp)
(global-set-key (kbd "C-M-s") 'isearch-forward)
(global-set-key (kbd "C-M-r") 'isearch-backward)
#+end_src

*** Jump to a definition in the current file. (This is awesome.)
#+begin_src emacs-lisp 
(global-set-key (kbd "C-x C-i") 'ido-imenu)
#+end_src

*** File finding
#+begin_src emacs-lisp 
(global-set-key (kbd "C-x M-f") 'ido-find-file-other-window)
(global-set-key (kbd "C-x C-M-f") 'find-file-in-project)
(global-set-key (kbd "C-x f") 'recentf-ido-find-file)
(global-set-key (kbd "C-x C-p") 'find-file-at-point)
(global-set-key (kbd "C-c y") 'bury-buffer)
(global-set-key (kbd "C-c r") 'revert-buffer)
(global-set-key (kbd "M-`") 'file-cache-minibuffer-complete)
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

*** Window switching. (C-x o goes to the next window)
#+begin_src emacs-lisp 
(windmove-default-keybindings) ;; Shift+direction
(global-set-key (kbd "C-x O") (lambda () (interactive) (other-window -1))) ;; back one
(global-set-key (kbd "C-x C-o") (lambda () (interactive) (other-window 2))) ;; forward two
#+end_src

*** Indentation help
#+begin_src emacs-lisp 
(global-set-key (kbd "C-x ^") 'join-line)
#+end_src

*** Start eshell or switch to it if it's active.
#+begin_src emacs-lisp 
(global-set-key (kbd "C-x m") 'eshell)
#+end_src

*** Start a new eshell even if one is active.
#+begin_src emacs-lisp 
(global-set-key (kbd "C-x M") (lambda () (interactive) (eshell t)))
#+end_src

*** Start a regular shell if you prefer that.
#+begin_src emacs-lisp 
(global-set-key (kbd "C-x M-m") 'shell)
#+end_src

*** If you want to be able to M-x without meta
#+begin_src emacs-lisp 
(global-set-key (kbd "C-x C-m") 'execute-extended-command)
#+end_src

*** Fetch the contents at a URL, display it raw.
#+begin_src emacs-lisp 
(global-set-key (kbd "C-x h") 'view-url)
#+end_src

*** Help should search more than just commands
#+begin_src emacs-lisp 
(global-set-key (kbd "C-h a") 'apropos)
#+end_src

*** Should be able to eval-and-replace anywhere.
#+begin_src emacs-lisp 
(global-set-key (kbd "C-c e") 'eval-and-replace)
#+end_src

*** Applications
#+begin_src emacs-lisp 

(global-set-key (kbd "C-c j") (lambda () (interactive) (switch-or-start 'jabber-connect "*-jabber-*")))
(global-set-key (kbd "C-c g") (lambda () (interactive) (switch-or-start 'gnus "*Group*")))
(global-set-key (kbd "C-c i") (lambda () (interactive) (switch-or-start (lambda ()
                                                                     (rcirc-connect "irc.freenode.net"))
                                                                   "*irc.freenode.net*")))
(global-set-key (kbd "C-c J") 'jabber-send-presence)
(global-set-key (kbd "C-c M-j") 'jabber-disconnect)
(global-set-key (kbd "C-x g") 'magit-status)
#+end_src

*** This is a little hacky since VC doesn't support git add internally
#+begin_src emacs-lisp 
(eval-after-load 'vc
  (define-key vc-prefix-map "i" '(lambda () (interactive)
                                   (if (not (eq 'Git (vc-backend buffer-file-name)))
                                       (vc-register)
                                     (shell-command (format "git add %s" buffer-file-name))
                                     (message "Staged changes.")))))
#+end_src

*** Activate occur easily inside isearch
#+begin_src emacs-lisp 
(define-key isearch-mode-map (kbd "C-o")
  (lambda () (interactive)
    (let ((case-fold-search isearch-case-fold-search))
      (occur (if isearch-regexp isearch-string (regexp-quote isearch-string))))))
#+end_src

*** Closing
#+begin_src emacs-lisp 
(provide 'starter-kit-bindings)
;;; starter-kit-bindings.el ends here
#+end_src

** Starter Kit Registers
Registers allow you to jump to a file or other location quickly. Use
=C-x r j= followed by the letter of the register (i for =init.el=, s
for this file) to jump to it.

You should add registers here for the files you edit most often.

#+srcname: starter-kit-registers
#+begin_src emacs-lisp 
  (dolist (r `((?i (file . ,(concat dotfiles-dir "init.el")))
               (?s (file . ,(concat dotfiles-dir "starter-kit.org")))))
    (set-register (car r) (cadr r)))
#+end_src

** Starter Kit Misc

*** Window system stuff

#+srcname: starter-kit-window-view-stuff
#+begin_src emacs-lisp 
(when window-system
  (setq frame-title-format '(buffer-file-name "%f" ("%b")))
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (blink-cursor-mode -1))

(mouse-wheel-mode t)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

(setq visible-bell t
      echo-keystrokes 0.1
      font-lock-maximum-decoration t
      inhibit-startup-message t
      transient-mark-mode t
      color-theme-is-global t
      delete-by-moving-to-trash t
      shift-select-mode nil
      truncate-partial-width-windows nil
      uniquify-buffer-name-style 'forward
      whitespace-style '(trailing lines space-before-tab
                                  indentation space-after-tab)
      whitespace-line-column 100
      ediff-window-setup-function 'ediff-setup-windows-plain
      oddmuse-directory (concat dotfiles-dir "oddmuse")
      xterm-mouse-mode t
      save-place-file (concat dotfiles-dir "places"))
#+end_src

*** Set browser
Set this to whatever browser you use e.g...
: ;; (setq browse-url-browser-function 'browse-url-firefox)
: ;; (setq browse-url-browser-function 'browse-default-macosx-browser)
: ;; (setq browse-url-browser-function 'browse-default-windows-browser)
: ;; (setq browse-url-browser-function 'browse-default-kde)
: ;; (setq browse-url-browser-function 'browse-default-epiphany)
: ;; (setq browse-url-browser-function 'browse-default-w3m)
: ;; (setq browse-url-browser-function 'browse-url-generic
: ;;       browse-url-generic-program "~/src/conkeror/conkeror")

*** Transparently open compressed files
#+begin_src emacs-lisp
(auto-compression-mode t)
#+end_src

*** Enable syntax highlighting for older Emacsen that have it off
#+begin_src emacs-lisp
(global-font-lock-mode t)
#+end_src

*** No Menu Bar
You really don't need this; trust me.
#+srcname: starter-kit-no-menu
#+begin_src emacs-lisp 
(menu-bar-mode -1)
#+end_src

*** Save a list of recent files visited.
#+begin_emacs-lisp 
(recentf-mode 1)
#+end_emacs-lisp

*** Highlight matching parentheses when the point is on them.
#+srcname: starter-kit-match-parens
#+begin_src emacs-lisp 
(show-paren-mode 1)
#+end_src

*** ido mode
ido-mode is like magic pixie dust!
#+srcname: starter-kit-loves-ido-mode
#+begin_src emacs-lisp 
(when (> emacs-major-version 21)
  (ido-mode t)
  (setq ido-enable-prefix nil
        ido-enable-flex-matching t
        ido-create-new-buffer 'always
        ido-use-filename-at-point t
        ido-max-prospects 10))
#+end_src

*** Other
#+begin_src emacs-lisp 
  (set-default 'indent-tabs-mode nil)
  (set-default 'indicate-empty-lines t)
  (set-default 'imenu-auto-rescan t)
  
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'text-mode-hook 'turn-on-flyspell)
  
  (defvar coding-hook nil
    "Hook that gets run on activation of any programming mode.")
  
  (defalias 'yes-or-no-p 'y-or-n-p)
  (random t) ;; Seed the random-number generator
#+end_src

*** Hippie expand: at times perhaps too hip
#+begin_src emacs-lisp
(delete 'try-expand-line hippie-expand-try-functions-list)
(delete 'try-expand-list hippie-expand-try-functions-list)
#+end_src

*** Don't clutter up directories with files~
#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name
                                        (concat dotfiles-dir "backups")))))
#+end_src

*** nxhtml stuff
#+begin_src emacs-lisp
(setq mumamo-chunk-coloring 'submode-colored
      nxhtml-skip-welcome t
      indent-region-mode t
      rng-nxml-auto-validate-flag nil)
#+end_src

*** Associate modes with file extensions
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("COMMIT_EDITMSG$" . diff-mode))
(add-to-list 'auto-mode-alist '("\\.css$" . css-mode))
(add-to-list 'auto-mode-alist '("\\.ya?ml$" . yaml-mode))
(add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
(add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
(add-to-list 'auto-mode-alist '("\\.js\\(on\\)?$" . js2-mode))
(add-to-list 'auto-mode-alist '("\\.xml$" . nxml-mode))
#+end_src

*** Default to unified diffs
#+begin_src emacs-lisp
(setq diff-switches "-u")
#+end_src

*** Cosmetics

#+begin_src emacs-lisp
(eval-after-load 'diff-mode
  '(progn
     (set-face-foreground 'diff-added "green4")
     (set-face-foreground 'diff-removed "red3")))

(eval-after-load 'magit
  '(progn
     (set-face-foreground 'magit-diff-add "green3")
     (set-face-foreground 'magit-diff-del "red3")))

(eval-after-load 'nxhtml
  '(eval-after-load 'zenburn
     '(set-face-background 'mumamo-background-chunk-submode "gray22")))
#+end_src

** Starter Kit Eshell
[[http://www.emacswiki.org/emacs/CategoryEshell][Eshell]] is a great shell.

#+begin_src emacs-lisp
  (setq eshell-cmpl-cycle-completions nil
        eshell-save-history-on-exit t
        eshell-cmpl-dir-ignore "\\`\\(\\.\\.?\\|CVS\\|\\.svn\\|\\.git\\)/\\'")
  
  (eval-after-load 'esh-opt
    '(progn
       (require 'em-prompt)
       (require 'em-term)
       (require 'em-cmpl)
       ;; TODO: for some reason requiring this here breaks it, but
       ;; requiring it after an eshell session is started works fine.
       ;; (require 'eshell-vc)
       (setenv "PAGER" "cat")
       (set-face-attribute 'eshell-prompt nil :foreground "turquoise1")
       (add-hook 'eshell-mode-hook ;; for some reason this needs to be a hook
                 '(lambda () (define-key eshell-mode-map "\C-a" 'eshell-bol)))
       (add-to-list 'eshell-visual-commands "ssh")
       (add-to-list 'eshell-visual-commands "tail")
       (add-to-list 'eshell-command-completions-alist
                    '("gunzip" "gz\\'"))
       (add-to-list 'eshell-command-completions-alist
                    '("tar" "\\(\\.tar|\\.tgz\\|\\.tar\\.gz\\)\\'"))
       (add-to-list 'eshell-output-filter-functions 'eshell-handle-ansi-color)))
#+end_src

** Starter Kit Lisp

*** Define keys
#+srcname: starter-kit-define-lisp-keys
#+begin_src emacs-lisp 
(define-key read-expression-map (kbd "TAB") 'lisp-complete-symbol)
(define-key lisp-mode-shared-map (kbd "C-c l") "lambda")
(define-key lisp-mode-shared-map (kbd "RET") 'reindent-then-newline-and-indent)
(define-key lisp-mode-shared-map (kbd "C-\\") 'lisp-complete-symbol)
(define-key lisp-mode-shared-map (kbd "C-c v") 'eval-buffer)
#+end_src

*** Paredit
[[http://www.emacswiki.org/emacs/ParEdit][Paredit]] might seem weird at first, but it really makes writing lisp a
much more comfortable experience.  This is especially useful in
combination with the sexp movement functions (=C-M-f= forward, =C-M-b=
back, =C-M-u= up, =C-M-d= down)

#+begin_src emacs-lisp
(defun turn-on-paredit ()
  (paredit-mode +1))
#+end_src

: ;; (eval-after-load 'paredit
: ;;      ;; Not sure why paredit behaves this way with comments; it's annoying
: ;;   '(define-key paredit-mode-map (kbd ";")   'self-insert-command))

*** Non-obtrusive parenthesis faces
#+begin_src emacs-lisp
(defface esk-paren-face
   '((((class color) (background dark))
      (:foreground "grey50"))
     (((class color) (background light))
      (:foreground "grey55")))
   "Face used to dim parentheses."
   :group 'starter-kit-faces)
#+end_src

*** Emacs Lisp

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
(add-hook 'emacs-lisp-mode-hook 'run-coding-hook)
(add-hook 'emacs-lisp-mode-hook 'esk-remove-elc-on-save)
;; (add-hook 'emacs-lisp-mode-hook 'idle-highlight)
(add-hook 'emacs-lisp-mode-hook 'turn-on-paredit)

(defun esk-remove-elc-on-save ()
  "If you're saving an elisp file, likely the .elc is no longer valid."
  (make-local-variable 'after-save-hook)
  (add-hook 'after-save-hook
            (lambda ()
              (if (file-exists-p (concat buffer-file-name "c"))
                  (delete-file (concat buffer-file-name "c"))))))

(font-lock-add-keywords 'emacs-lisp-mode
			'(("(\\|)" . 'esk-paren-face)))
#+end_src

*** Clojure

#+begin_src emacs-lisp
(add-hook 'clojure-mode-hook 'run-coding-hook)
;; (add-hook 'clojure-mode-hook 'idle-highlight)

(font-lock-add-keywords 'clojure-mode
                        '(("(\\|)" . 'esk-paren-face)))

(defface esk-clojure-trace-face
   '((((class color) (background dark))
      (:foreground "grey50"))
     (((class color) (background light))
      (:foreground "grey55")))
   "Face used to dim parentheses."
   :group 'starter-kit-faces)

(setq esk-clojure-trace-face 'esk-clojure-trace-face)

;; This will make relevant lines stand out more in stack traces
(defun sldb-font-lock ()
  (font-lock-add-keywords nil
                          '(("[0-9]+: \\(clojure\.\\(core\\|lang\\).*\\)"
                             1 esk-clojure-trace-face)
                            ("[0-9]+: \\(java.*\\)"
                             1 esk-clojure-trace-face)
                            ("[0-9]+: \\(swank.*\\)"
                             1 esk-clojure-trace-face)
                            ("\\[\\([A-Z]+\\)\\]"
                             1 font-lock-function-name-face))))

(add-hook 'sldb-mode-hook 'sldb-font-lock)

(defun slime-jump-to-trace (&optional on)
  "Jump to the file/line that the current stack trace line references.
Only works with files in your project root's src/, not in dependencies."
  (interactive)
  (save-excursion
    (beginning-of-line)
    (search-forward-regexp "[0-9]: \\([^$(]+\\).*?\\([0-9]*\\))")
    (let ((line (string-to-number (match-string 2)))
          (ns-path (split-string (match-string 1) "\\."))
          (project-root (locate-dominating-file default-directory "src/")))
      (find-file (format "%s/src/%s.clj" project-root
                         (mapconcat 'identity ns-path "/")))
      (goto-line line))))

(eval-after-load 'slime
  '(progn
     (defalias 'sldb-toggle-details 'slime-jump-to-trace)
     (defun sldb-prune-initial-frames (frames)
       "Show all stack trace lines by default."
       frames)))

(eval-after-load 'find-file-in-project
  '(add-to-list 'ffip-patterns "*.clj"))

;; You might like this, but it's a bit disorienting at first:
(add-hook 'clojure-mode-hook 'turn-on-paredit)

(defun clojure-project (path)
  "Setup classpaths for a clojure project and starts a new SLIME session.

Kills existing SLIME session, if any."
  (interactive (list
                (ido-read-directory-name
                 "Project root: "
                 (locate-dominating-file default-directory "pom.xml"))))
  (when (get-buffer "*inferior-lisp*")
    (kill-buffer "*inferior-lisp*"))
  (add-to-list 'swank-clojure-extra-vm-args
               (format "-Dclojure.compile.path=%s"
                       (expand-file-name "target/classes/" path)))
  (setq swank-clojure-binary nil
        swank-clojure-jar-path (expand-file-name "target/dependency/" path)
        swank-clojure-extra-classpaths
        (append (mapcar (lambda (d) (expand-file-name d path))
                        '("src/" "target/classes/" "test/"))
                (let ((lib (expand-file-name "lib" path)))
                  (if (file-exists-p lib)
                      (directory-files lib t ".jar$"))))
        slime-lisp-implementations
        (cons `(clojure ,(swank-clojure-cmd) :init swank-clojure-init)
              (remove-if #'(lambda (x) (eq (car x) 'clojure))
                         slime-lisp-implementations)))
  (save-window-excursion
    (slime)))
#+end_src

*** Scheme

#+begin_src emacs-lisp
(add-hook 'scheme-mode-hook 'run-coding-hook)
;; (add-hook 'scheme-mode-hook 'idle-highlight)
(font-lock-add-keywords 'scheme-mode
			'(("(\\|)" . 'esk-paren-face)))
#+end_src

*** Common Lisp

#+begin_src emacs-lisp
(add-hook 'lisp-mode-hook 'run-coding-hook)
;; (add-hook 'lisp-mode-hook 'idle-highlight)
(add-hook 'lisp-mode-hook 'turn-on-paredit)
(font-lock-add-keywords 'lisp-mode
			'(("(\\|)" . 'esk-paren-face)))
#+end_src

** Starter Kit Ruby

#+begin_src emacs-lisp
(eval-after-load 'ruby-mode
  '(progn
     ;; work around possible elpa bug
     (ignore-errors (require 'ruby-compilation))
     (setq ruby-use-encoding-map nil)
     (add-hook 'ruby-mode-hook 'inf-ruby-keys)
     (define-key ruby-mode-map (kbd "RET") 'reindent-then-newline-and-indent)
     (define-key ruby-mode-map (kbd "C-M-h") 'backward-kill-word)
     (define-key ruby-mode-map (kbd "C-c l") "lambda")))
#+end_src

#+begin_src emacs-lisp
(global-set-key (kbd "C-h r") 'ri)
#+end_src

*** Rake files are ruby, too, as are gemspecs.
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.rake$" . ruby-mode))
(add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
(add-to-list 'auto-mode-alist '("\\.gemspec$" . ruby-mode))
#+end_src

*** We never want to edit Rubinius bytecode
#+begin_src emacs-lisp
(add-to-list 'completion-ignored-extensions ".rbc")
#+end_src

*** Rake

#+begin_src emacs-lisp
(defun pcomplete/rake ()
  "Completion rules for the `ssh' command."
  (pcomplete-here (pcmpl-rake-tasks)))

(defun pcmpl-rake-tasks ()
   "Return a list of all the rake tasks defined in the current
projects.  I know this is a hack to put all the logic in the
exec-to-string command, but it works and seems fast"
   (delq nil (mapcar '(lambda(line)
			(if (string-match "rake \\([^ ]+\\)" line) (match-string 1 line)))
		     (split-string (shell-command-to-string "rake -T") "[\n]"))))

(defun rake (task)
  (interactive (list (completing-read "Rake (default: default): "
                                      (pcmpl-rake-tasks))))
  (shell-command-to-string (concat "rake " (if (= 0 (length task)) "default" task))))
#+end_src

*** Compilation
Clear the compilation buffer between test runs.

#+begin_src emacs-lisp
(eval-after-load 'ruby-compilation
  '(progn
     (defadvice ruby-do-run-w/compilation (before kill-buffer (name cmdlist))
       (let ((comp-buffer-name (format "*%s*" name)))
         (when (get-buffer comp-buffer-name)
           (with-current-buffer comp-buffer-name
             (delete-region (point-min) (point-max))))))
     (ad-activate 'ruby-do-run-w/compilation)))
#+end_src

*** Hooks
#+begin_src emacs-lisp
(add-hook 'ruby-mode-hook 'run-coding-hook)
#+end_src

#+begin_emacs-lisp
;; (add-hook 'ruby-mode-hook 'idle-highlight)
#+end_emacs-lisp

*** Flymake

#+begin_src emacs-lisp
(eval-after-load 'ruby-mode
  '(progn
     (require 'flymake)

     ;; Invoke ruby with '-c' to get syntax checking
     (defun flymake-ruby-init ()
       (let* ((temp-file (flymake-init-create-temp-buffer-copy
                          'flymake-create-temp-inplace))
              (local-file (file-relative-name
                           temp-file
                           (file-name-directory buffer-file-name))))
         (list "ruby" (list "-c" local-file))))

     (push '(".+\\.rb$" flymake-ruby-init) flymake-allowed-file-name-masks)
     (push '("Rakefile$" flymake-ruby-init) flymake-allowed-file-name-masks)

     (push '("^\\(.*\\):\\([0-9]+\\): \\(.*\\)$" 1 2 nil 3)
           flymake-err-line-patterns)

     (add-hook 'ruby-mode-hook
               (lambda ()
                 (when (and buffer-file-name
                            (file-writable-p
                             (file-name-directory buffer-file-name))
                            (file-writable-p buffer-file-name))
                   (local-set-key (kbd "C-c d")
                                  'flymake-display-err-menu-for-current-line)
                   (flymake-mode t))))))
#+end_src

*** Rinari (Minor Mode for Ruby On Rails)
See [[http://rinari.rubyforge.org/][rinari.rubyforge]] for more information on rinari.

#+begin_src emacs-lisp
(setq rinari-major-modes
      (list 'mumamo-after-change-major-mode-hook 'dired-mode-hook 'ruby-mode-hook
	    'css-mode-hook 'yaml-mode-hook 'javascript-mode-hook))
#+end_src

** Starter Kit JS
Java-script Helpers

#+begin_src emacs-lisp
(font-lock-add-keywords
 'espresso-mode `(("\\(function *\\)("
                   (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                             "ƒ")
                             nil)))))
#+end_src

#+begin_src emacs-lisp
(font-lock-add-keywords 'espresso-mode
                        '(("\\<\\(FIX\\|TODO\\|FIXME\\|HACK\\|REFACTOR\\):"
                           1 font-lock-warning-face t)))
#+end_src

#+begin_src emacs-lisp
(autoload 'espresso-mode "espresso" "Start espresso-mode" t)
(add-to-list 'auto-mode-alist '("\\.js$" . espresso-mode))
(add-to-list 'auto-mode-alist '("\\.json$" . espresso-mode))
(add-hook 'espresso-mode-hook 'moz-minor-mode)
(add-hook 'espresso-mode-hook 'turn-on-paredit)
(add-hook 'espresso-mode-hook 'run-coding-hook)
;; (add-hook 'espresso-mode-hook 'idle-highlight)
(setq espresso-indent-level 2)
#+end_src

#+begin_src emacs-lisp
(defun esk-pp-json ()
  "Pretty-print the json object following point."
  (interactive)
  (require 'json)
  (let ((json-object (save-excursion (json-read))))
    (switch-to-buffer "*json*")
    (delete-region (point-min) (point-max))
    (insert (pp json-object))
    (goto-char (point-min))))
#+end_src

** Starter Kit Perl

#+begin_src emacs-lisp
(eval-after-load 'cperl-mode
  '(progn
     (define-key cperl-mode-map (kbd "RET") 'reindent-then-newline-and-indent)
     (define-key cperl-mode-map (kbd "C-M-h") 'backward-kill-word)))

(global-set-key (kbd "C-h P") 'perldoc)

(add-to-list 'auto-mode-alist '("\\.p[lm]$" . cperl-mode))
(add-to-list 'auto-mode-alist '("\\.pod$" . pod-mode))
(add-to-list 'auto-mode-alist '("\\.tt$" . tt-mode))
#+end_src


* Development

** Tasks [1/10]

*** TODO setup electric for ruby
*** TODO set up ri for ruby
*** TODO Submit the packages in starter-kit-elpa.el to ELPA.

*** STARTED Greg Newman is working on Python helpers.

*** STARTED submit ruby fixes to flymake

*** PROPOSED which-func-mode in ruby?
*** TODO all bindings to kbd invocations

*** DEFERRED should yasnippet be included in rinari?
No, rinari has no dependency on yasnippet, and yasnippet has many
applications outside of rinari.

*** TODO flymake for perl
*** TODO electric bugaloo for perl


** Bugs [0/1]
*** TODO get jabber.el to automatically disconnect when suspending/hibernating (via dbus)


* Footnotes

[1] If you already have a directory at ~/.emacs.d move it out of
the way and put this there instead.

[2] The emacs starter kit uses [[http://github.com/eschulte/org-babel/tree/master][org-babel]] to load embedded elisp code
directly from [[http://orgmode.org/][Org Mode]] documents.

